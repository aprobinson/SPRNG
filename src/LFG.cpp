// Copyright 1996 September 3, United States Government as Represented   
// by the Director, National Security Agency. All rights reserved.       
//                                                                       
// Disclaimer 1: NCSA expressly disclaims any and all warranties, expressed
// or implied, concerning the enclosed software.  The intent in sharing  
// this software is to promote the productive interchange of ideas       
// throughout the research community. All software is furnished on an    
// "as is" basis. No further updates to this software should be          
// expected. Although this may occur, no commitment exists. The authors  
// certainly invite your comments as well as the reporting of any bugs.  
// NCSA cannot commit that any or all bugs will be fixed.                
//                                                                       
// Disclaimer 2: CCS expressly disclaims any and all warranties, expressed 
// or implied, concerning the enclosed software. This software was       
// developed at CCS for use in internal research. The intent in sharing  
// this software is to promote the productive interchange of ideas       
// throughout the research community. All software is furnished on an    
// "as is" basis. No further updates to this software should be          
// expected. Although this may occur, no commitment exists. The authors  
// certainly invite your comments as well as the reporting of any bugs.  
// CCS cannot commit that any or all bugs will be fixed.                 
//---------------------------------------------------------------------------//
//!
//! \file    LFG.hpp
//! \author  Steven A. Cuccaro and Daniel V. Pryor, Askov Srinivasan 
//!          (IDA/Center for Computing Sciences (CCS), cuccaro@super.org, 
//!           pryor@super.org, ?)
//! \brief   Parallel modified additive lagged fibonacci generator definition
//! \details Modified by J. Ren (Florida State University, ren@csit.fsu.edu ).
//!          This version has been modified to use two integer-based additive
//!          lagged-Fibonacci generators to produce integer, float and double
//!          values. The lagged-Fibonacci generators each have 31 bits of 
//!          precision (after the bit fixed by the canonical form of the  
//!          generator is removed), 31-bit values are generated by XORing     
//!          the values after one has been shifted left one bit. The floating 
//!          point value is formed by dividing the integer by 1.e+32 (the     
//!          lsb's will be dropped from the mantissa to make room for the     
//!          exponent), and two of these integer values in sequence are used  
//!          to get the necessary precision for the double value. This method 
//!          has the advantage that the generators pass fairly strict 
//!          randomness tests, including the Birthday Spacings test that 
//!          additive lagged-Fibonacci generators are well known to fail. The 
//!          disadvantage is the additional time needed to do the division 
//!          explicitly, which was avoided in previous versions. (As the 
//!          division is by powers of 2, the user might well consider making 
//!          machine-specific versions of this code to insert the bits into 
//!          the appropriate places and avoid the problem entirely.) 
//! \note    This file has been rewritten by Alex Robinson (University of
//!          Wisconsin-Madison, aprobinson@wisc.edu). Only minor interface
//!          changes have been made. All of the underlying algorithms are still
//!          the same.
//!
//---------------------------------------------------------------------------//

// Std Lib Includes
#include <assert.h>

// Boost Includes
#include <boost/scoped_ptr.hpp>

// SPRNG Includes
#include "LFG.hpp"
#include "Store.hpp"

#define GENTYPE "Additive Lagged Fibonacci Generator"
#define INT_MOD_MASK 0xffffffff
#define FLT_MULT (0.25/(unsigned)(1<<30))
// INT_MASK is used to mask out the part of the generator which is not in the 
// canonical form; it should be 2^{32-1}-1 
#define INT_MASK ((unsigned)INT_MOD_MASK>>1)
// MAX_BIT_INT is the largest bit position allowed in the index of the node - 
// it equals 32 - 2
#define MAX_BIT_INT (32-2)
// INTX2_MASK is used in calculation of the node numbers
#define INTX2_MASK ((1<<MAX_BIT_INT)-1)
// RUNUP keeps certain generators from looking too similar in the first few 
// words output                                    
#define RUNUP (2*32)
// GS0 gives a more "random" distribution of generators when the user uses 
// small integers as seeds
#define GS0 0x372f05ac

namespace sprng{

// Initialize static member data
int LFG::num_generators = 0;
int LFG::global_seed = 0;
int LFG::global_lval = 0;
int LFG::global_kval = 0;
const LFG::vstruct LFG::valid[] = 
  { {1279,861,1,233}, {17,5,1,10}, {31,6,1,2},
    {55,24,1,11}, {63,31,1,14}, {127,97,1,21}, {521,353,1,100},
    {521,168,1,83}, {607,334,1,166}, {607,273,1,105}, {1279,418,1,208}};

// Default constructor
LFG::LFG() 
  : d_rng_type( LFG_TYPE ),
    d_gentype( GENTYPE ),
    d_si(),
    d_r0(),
    d_r1(),
    d_stream_number( 0 ),
    d_hptr( 0 ),
    d_seed( 0 ),
    d_init_seed( 0 ),
    d_lval( 0 ),
    d_kval( 0 ),
    d_param( 0 )
{ /* ... */ }

// Copy constructor
LFG::LFG( const LFG &c )
  : d_rng_type( c.d_rng_type ),
    d_gentype( c.d_gentype ),
    d_si( c.d_si ),
    d_r0( c.d_r0 ),
    d_r1( c.d_r1 ),
    d_stream_number( c.d_stream_number ),
    d_hptr( c.d_hptr ),
    d_seed( c.d_seed ),
    d_init_seed( c.d_init_seed ),
    d_lval( c.d_lval ),
    d_kval( c.d_kval ),
    d_param( c.d_param )
{ /* ... */ }

// Assignment operator
LFG& LFG::operator=( const LFG &c )
{
  if( this != &c )
  {
    this->free_rng();

    d_rng_type = c.d_rng_type;
    d_gentype = c.d_gentype;
    d_si = c.d_si;
    d_r0 = c.d_r0;
    d_stream_number = c.d_stream_number;
    d_hptr = c.d_hptr;
    d_seed = c.d_seed;
    d_init_seed = c.d_init_seed;
    d_lval = c.d_lval;
    d_kval = c.d_kval;
    d_param = c.d_param;
  }

  return *this;
}

// Destructor
LFG::~LFG()
{
  free_rng();
}

// Initialize the generator
/*! \details Give back one generator (node gn) with updated spawning info. This
 * function should be called tg times, with a different value of gn in [0,tn)
 * each call.
 */
int LFG::init_rng( int gn, int tg, int s, int m )
{
  int i, k, length;

  // Check if tg is valid
  if( tg <= 0 ) 
  {
    std::cerr << "WARNING - init_rng: total_gen <= 0. "
	      << "Default value of 1 used for total_gen." 
	      << std::endl;
    tg = 1;
  }
  
  // Check if gn is in range
  if( gn < 0 || gn >= tg ) 
  {
    std::cerr << "ERROR - init_rng: gennum " << gn << " out of range "
	      << "(0," << tg << ")" << std::endl;
    return 0;
  }

  // Only 31 LSB of seed considered
  s &= 0x7fffffff;		
  
  // Check if the parameter is in range
  if (m < 0 || m >= 11) 
  {
    std::cerr << "WARNING - init_rng: Parameter not valid. "
	      << "Using defulat param (m=" << 0 << ")"
	      << std::endl;
    m = 0;
  }
  
  length = LFG::valid[m].L; 
  k = LFG::valid[m].K;

  // Check whether generators have previously been defined. Guard against
  // access while defining generator parameters for the first time.
  if ( !LFG::global_lval ) 
  {
    LFG::global_lval = length; 
    LFG::global_kval = k;
    LFG::global_seed = s^GS0;
  }

  // Check if the global variables will be changed
  else 
  {
    if( LFG::global_lval != length )
    { 
      std::cerr << "WARNING - init_rng: changing global L value! "
		<< "Independence of streams is not guaranteed."
		<< std::endl;
    }
    if( s != (LFG::global_seed^GS0) ) 
    {
      std::cerr << "WARNING - init_rng: changing global seed value! "
		<< "Independence of streams is not guaranteed."
		<< std::endl;
    }
  }
  
  // Define the starting vector for the initial node 
  boost::shared_array<unsigned> nstart( new unsigned[length-1] );
  nstart[0] = gn;

  for( i=1; i<length-1; i++ ) 
    nstart[i] = 0;

  // Create a generator
  LFG **p = LFG::initialize( d_rng_type , 1, m, s^GS0, nstart, s );  

  if( p == NULL ) 
    return 0;
  
  p[0]->d_stream_number = gn;

  // Update si array to allow for future spawning of generators
  boost::shared_array<unsigned> si_local = p[0]->d_si;

  while( si_local[0] < tg && !si_local[1] ) 
    LFG::si_double(si_local,si_local,length);
 
  d_rng_type = LFG_TYPE;
  d_gentype = p[0]->d_gentype;
  
  // A deep copy must be done on the member arrays so that the initialized
  // LFG pointer can be freed.
  LFG::deep_copy( p[0]->d_si, d_si, length-1 );
  LFG::deep_copy( p[0]->d_r0, d_r0, length );
  LFG::deep_copy( p[0]->d_r1, d_r1, length );
  
  d_stream_number = p[0]->d_stream_number;
  d_hptr = p[0]->d_hptr;
  d_seed = p[0]->d_seed;
  d_init_seed = p[0]->d_init_seed;
  d_lval = p[0]->d_lval;
  d_kval = p[0]->d_kval;
  d_param = p[0]->d_param;

  delete p[0];
  delete[] p;

  // Increment the number of open streams (on process)
  // 2 must be added to account for -1 from delete p[0]
  LFG::increment_number_of_streams( 2 );

  return 1;
}
  
// Return a random int
int LFG::get_rn_int()
{
  unsigned new_val;
  int hptr_local,lptr;
  int local_lval, local_kval;
  
  local_lval = d_lval;
  local_kval = d_kval;
  hptr_local = d_hptr;
  lptr = hptr_local + local_kval;
  
  if( lptr >= local_lval ) 
    lptr -= local_lval;
  
  // INT_MOD_MASK causes arithmatic to be modular when integer size is
  // different from the generator modulus
  d_r0[hptr_local] = INT_MOD_MASK&(d_r0[hptr_local] + d_r0[lptr]);
  d_r1[hptr_local] = INT_MOD_MASK&(d_r1[hptr_local] + d_r1[lptr]);
  new_val = (d_r1[hptr_local]&(~1)) ^ (d_r0[hptr_local]>>1);
  
  if( --hptr_local < 0 ) 
    hptr_local = local_lval - 1; // skip an element in the sequence
    
  if( --lptr < 0 ) 
    lptr = local_lval - 1;
    
  d_r0[hptr_local] = INT_MOD_MASK&(d_r0[hptr_local] + d_r0[lptr]);
  d_r1[hptr_local] = INT_MOD_MASK&(d_r1[hptr_local] + d_r1[lptr]);
  d_hptr = (--hptr_local < 0) ? local_lval-1 : hptr_local;
  
  return (new_val>>1);
}

// Return a random float in interval [0,1)
float LFG::get_rn_flt()
{
  // Use unsigned long instead of unsigned int due to bug in SGI compiler
  unsigned long new_val; 
  int hptr_local, lptr;
  int local_lval, local_kval;
	
  local_lval = d_lval;
  local_kval = d_kval;
  hptr_local = d_hptr;
  lptr = hptr_local + local_kval;
  
  if( lptr >= local_lval ) 
    lptr -= local_lval;

  // INT_MOD_MASK causes arithmetic to be modular when integer size is 
  // different from generator modulus 
  d_r0[hptr_local] = INT_MOD_MASK&(d_r0[hptr_local] + d_r0[lptr]);
  d_r1[hptr_local] = INT_MOD_MASK&(d_r1[hptr_local] + d_r1[lptr]);
  new_val = (d_r1[hptr_local]&(~1)) ^ (d_r0[hptr_local]>>1);

  if( --hptr_local < 0 ) 
    hptr_local = local_lval - 1; // skip an element in the sequence
  
  if( --lptr < 0 ) 
    lptr = local_lval - 1;

  d_r0[hptr_local] = INT_MOD_MASK&(d_r0[hptr_local] + d_r0[lptr]);
  d_r1[hptr_local] = INT_MOD_MASK&(d_r1[hptr_local] + d_r1[lptr]);
  
  d_hptr = (--hptr_local<0) ? local_lval-1 : hptr_local;

  return new_val*FLT_MULT;
}

// Return a random double in interval [0,1)
double LFG::get_rn_dbl()
{
  // Use unsigned long instead of unsigned int due to bug in SGI compiler
  unsigned long temp1,temp2; 
  int hptr_local,lptr;
  double new_val;
  int local_lval, local_kval;
	
  local_lval = d_lval;
  local_kval = d_kval;
  hptr_local = d_hptr;
  lptr = hptr_local + local_kval;

  if( lptr >= local_lval ) 
    lptr -= local_lval;

  // INT_MOD_MASK causes arithmetic to be modular when integer size is 
  // different from generator modulus
  d_r0[hptr_local] = INT_MOD_MASK&(d_r0[hptr_local] + d_r0[lptr]);
  d_r1[hptr_local] = INT_MOD_MASK&(d_r1[hptr_local] + d_r1[lptr]);
  temp1 = (d_r1[hptr_local]&(~1)) ^ (d_r0[hptr_local]>>1);

  if( --hptr_local < 0 ) 
    hptr_local = local_lval - 1;
  
  if( --lptr < 0 ) 
    lptr = local_lval - 1;
  
  d_r0[hptr_local] = INT_MOD_MASK&(d_r0[hptr_local] + d_r0[lptr]);
  d_r1[hptr_local] = INT_MOD_MASK&(d_r1[hptr_local] + d_r1[lptr]);
  temp2 = (d_r1[hptr_local]&(~1)) ^ (d_r0[hptr_local]>>1);
  d_hptr = (--hptr_local < 0) ? local_lval-1 : hptr_local;

  new_val = ((unsigned int) temp2*(double)FLT_MULT + 
	     (unsigned int) temp1)*FLT_MULT;

  return new_val;
}

// Spawn new generators
int LFG::spawn_rng( int nspawned, Sprng ***newgens )
{
  
  int i;
  
  // Check if nspawned is valid
  if( nspawned <= 0 ) 
  {
    nspawned = 1;
    std::cerr << "WARNING - spawn_rng: nsawneed <= 0. "
	      << "Default value of 1 used for nspawned."
	      << std::endl;
  }
  
  boost::shared_array<unsigned> p = d_si;
  LFG **q = LFG::initialize(d_rng_type,nspawned,d_param,d_seed,p,d_init_seed);

  if( q == NULL )
  {
    *newgens = NULL;
    return 0;
  }
  
  LFG::si_double(p,p,d_lval);

  // Increment the number of open streams
  LFG::increment_number_of_streams( nspawned );
      
  *newgens = (Sprng **) q;

  return nspawned;
}

int LFG::spawn_rng( int nspawned,
		    std::vector<boost::shared_ptr<Sprng> > &newgens )
{
  Sprng **tmp_newgens;

  // Number of generators spawned
  int val = spawn_rng( nspawned, &tmp_newgens );

  newgens.resize( val );

  for( int i = 0; i < val; ++i )
    newgens[i].reset( tmp_newgens[i] );

  delete[] tmp_newgens;

  return val;
}

// Return the generator seed
int LFG::get_seed_rng()
{
  return (GS0^LFG::global_seed);
}

// Decrement the number of generator streams
/* \details This function is called by the destructor and should therefore
 * never be called directly
 */
int LFG::free_rng()
{
  LFG::decrement_number_of_streams();
    
  return LFG::num_generators;
}

// Pack this generator into a character buffer
/*! \details A null character buffer should be passed to this function. The
 * new command will be used to allocate the correct amount of memory. Just
 * remember to call delete[] on the buffer when you are done using it.
 */
int LFG::pack_rng( char **buffer )
{
  std::string tmp_buffer;
  
  int val = pack_rng( tmp_buffer );
  
  *buffer = new char[tmp_buffer.size()];
  
  tmp_buffer.copy( *buffer, tmp_buffer.size() );

  return val;
}

int LFG::pack_rng( std::string &buffer ) const
{
  // Clear the buffer
  buffer.clear();

  // All member data will be stored in a sub buffer and appended to main buffer
  std::string partial_buffer;

  // Store the generator type
  store_value( generatorTypeToInt( d_rng_type ), partial_buffer );
  buffer += partial_buffer;

  // Store the L value
  store_value( d_lval, partial_buffer );
  buffer += partial_buffer;
  
  // Store the K value
  store_value( d_kval, partial_buffer );
  buffer += partial_buffer;
  
  // Store the seed
  store_value( d_seed, partial_buffer );
  buffer += partial_buffer;
  
  // Store the initial seed
  store_value( d_init_seed, partial_buffer );
  buffer += partial_buffer;
  
  // Store the stream number
  store_value( d_stream_number, partial_buffer );
  buffer += partial_buffer;
  
  // Store the next branch seeds
  store_array( d_si, d_lval-1, partial_buffer );
  buffer += partial_buffer;

  // Store the even generator
  store_array( d_r0, d_lval, partial_buffer );
  buffer += partial_buffer;
  
  // Store the odd generator
  store_array( d_r1, d_lval, partial_buffer );
  buffer += partial_buffer;
  
  // Store the integer pointer into fill
  store_value( d_hptr, partial_buffer );
  buffer += partial_buffer;
    
  return buffer.size();
}

// Print this generators info
int LFG::print_rng()
{
  print( std::cout );
  
  return 1;  
}

void LFG::print( std::ostream &os ) const
{
  os << d_gentype << ":" << std::endl 
     << "  seed = " << d_init_seed << "," << std::endl
     << "  stream_number = " << d_stream_number << "," << std::endl
     << "  parameter = " << d_param << std::endl;
}

// Unpack this generator from a character buffer
int LFG::unpack_rng( char *packed )
{
  int i, found, length, k;
  int local_seed, local_param;
  std::size_t nbytes;
  int generator_type;
  int local_lval, local_kval;
  bool valid_values = false;
  std::string sub_string;

  // Load the generator type
  nbytes = sizeof( generator_type );
  sub_string.assign( packed, nbytes );
  load_value( sub_string, generator_type );
  d_rng_type = intToGeneratorType( generator_type );
  packed += nbytes;

  // Load the generator description (not packed because always the same)
  d_gentype = GENTYPE;
  
  // Load the L value
  nbytes = sizeof( d_lval );
  sub_string.assign( packed, nbytes );
  load_value( sub_string, local_lval );
  packed += nbytes;

  // Load the K value
  nbytes = sizeof( d_kval );
  sub_string.assign( packed, nbytes );
  load_value( sub_string, local_kval );
  packed += nbytes;
  
  // Check that the L and K value found are valid
  for( i = 0; i < 11; ++i )
  {
    if( local_lval == LFG::valid[i].L && local_kval == LFG::valid[i].K )
    {
      valid_values = true;
      break;
    }
  }

  if( !valid_values )
  {
    std::cerr << "ERROR: Unpacked L and K values are not acceptable."
	      << std::endl;
    return 0;
  }

  local_param = i;
  length = valid[local_param].L;
  k = valid[local_param].K;

  // Set the L value K value and the parameter
  d_lval = length;
  d_kval = k;
  d_param = local_param;

  // Load the seed
  nbytes = sizeof( d_seed );
  sub_string.assign( packed, nbytes );
  load_value( sub_string, local_seed );
  packed += nbytes;
    
  // Check if this is the first stream and if the seed is valid
  if( !LFG::global_lval ) 
  {
    LFG::global_lval = length;
    LFG::global_kval = k;
    LFG::global_seed = local_seed;
  }
  else 
  {
    if( local_seed != LFG::global_seed )
    {
      std::cerr << "WARNGING -unpack_rng: different global seed value! "
		<< "Independence of streams is not guaranteed."
		<< std::endl;
    }
  }

  // Set the seed
  d_seed = local_seed;

  // Load the initial seed
  nbytes = sizeof( d_init_seed );
  sub_string.assign( packed, nbytes );
  load_value( sub_string, d_init_seed );
  packed += nbytes;

  // Load the stream number
  nbytes = sizeof( d_stream_number );
  sub_string.assign( packed, nbytes );
  load_value( sub_string, d_stream_number );
  packed += nbytes;
  
  // Resize the stored arrays
  d_si.reset( new unsigned[length - 1] );
  d_r0.reset( new unsigned[length] );
  d_r1.reset( new unsigned[length] );

  // Load the next branch seeds
  nbytes = sizeof( unsigned )*(length-1);
  sub_string.assign( packed, nbytes );
  load_array( sub_string, length-1, d_si );
  packed += nbytes;
  
  // Load the even generator
  nbytes = sizeof( unsigned )*length;
  sub_string.assign( packed, nbytes );
  load_array( sub_string, length, d_r0 );
  packed += nbytes;

  // Load the odd generator
  nbytes = sizeof( unsigned )*length;
  sub_string.assign( packed, nbytes );
  load_array( sub_string, length, d_r1 );
  packed += nbytes;
  
  // Load the integer pointer into fill
  nbytes = sizeof( d_hptr );
  sub_string.assign( packed, nbytes );
  load_value( sub_string, d_hptr );
  packed += nbytes;
  
  // Increment the number of streams
  LFG::increment_number_of_streams();

  return 1;
}

int LFG::unpack_rng( const std::string &packed )
{
  // Const cast so that the legacy unpack_rng interface can be called
  char* packed_string = const_cast<char*>( packed.c_str() );

  return unpack_rng( packed_string );
}

// Get the number of open streams
int LFG::get_number_of_streams()
{
  return LFG::num_generators;
}

// Get the bit count
int LFG::bitcnt( int x )
{
  unsigned i=0,y;

  for (y=(unsigned)x; y; y &= (y-1) ) 
    i++;

  return i;
}

// Advance the registers
/*! details The register steps according to the primitive polynomial
 * (64,4,3,1,0). Each call steps the register 64 times. Two words are used
 * to represent the register and to allow for an integer size of 32 bits.
 */
int LFG::advance_reg( boost::shared_array<int> &reg_fill )
{
  assert( reg_fill );
  
  const int mask = 0x1b;
  int adv_64[4][2];

  int i,new_fill[2];
  unsigned temp;

  adv_64[0][0] = 0xb0000000;
  adv_64[0][1] = 0x1b;
  adv_64[1][0] = 0x60000000;
  adv_64[1][1] = 0x2d;
  adv_64[2][0] = 0xc0000000;
  adv_64[2][1] = 0x5a;
  adv_64[3][0] = 0x80000000;
  adv_64[3][1] = 0xaf;
  new_fill[1] = new_fill[0] = 0;
  temp = mask<<27;

  for (i=27;i>=0;i--) 
  {
    new_fill[0] = (new_fill[0]<<1) | (1&bitcnt(reg_fill[0]&temp));
    new_fill[1] = (new_fill[1]<<1) | (1&bitcnt(reg_fill[1]&temp));
    temp >>= 1;
  }

  for (i=28;i<32;i++) 
  {
    temp = bitcnt(reg_fill[0]&(mask<<i));
    temp ^= bitcnt(reg_fill[1]&(mask>>(32-i)));
    new_fill[0] |= (1&temp)<<i;
    temp = bitcnt(reg_fill[0]&adv_64[i-28][0]);
    temp ^= bitcnt(reg_fill[1]&adv_64[i-28][1]);
    new_fill[1] |= (1&temp)<<i;
  }

  reg_fill[0] = new_fill[0];
  reg_fill[1] = new_fill[1];
}

// Get the register fill
/*! \details initialize the shift register with the node number XORed with the
 * global seed. Fill the shift register with two copies of this number except
 * when its equal to zero.
 */
int LFG::get_fill( boost::shared_array<unsigned> &n, 
		   boost::shared_array<unsigned> &r, 
		   int param_local, 
		   unsigned seed_local )
{
  assert( n );
  assert( r );
  
  int i,j,k, length;
  boost::shared_array<int> temp( new int[2] );

  length = LFG::valid[param_local].L;
  
  temp[1] = temp[0] = n[0]^seed_local;

  if ( !temp[0] )
    temp[0] = GS0;

  // Advance the shift register some
  advance_reg( temp );
  advance_reg( temp );

  // The first word in the generator is defined by the 31 LSBs of the node 
  // number 
  r[0] = (INT_MASK&n[0])<<1;
  
  // The generator is filled with the lower 31 bits of the shift register at 
  // each time, shifted up to make room for the bits defining the canonical 
  // form; the node number is XORed into the fill to make the generators unique
  for ( i=1; i<length-1 ; i++ ) 
  {
    advance_reg( temp );
    r[i] = (INT_MASK&(temp[0]^n[i]))<<1;
  }
  r[length-1] = 0;
  
  // The canonical form for the LSB is instituted here 
  k = LFG::valid[param_local].first + LFG::valid[param_local].LSBS;

  for ( j=LFG::valid[param_local].first; j<k; j++ )
    r[j] |= 1;

  return 0;
}

// Update index for next spawning
void LFG::si_double( boost::shared_array<unsigned> &a, 
		     boost::shared_array<unsigned> &b, 
		     int length )
{
  assert( a );
  assert( b );
  
  int i;

  if ( b[length-2]&(1<<MAX_BIT_INT) )
  {
    std::cerr << "Warning - si_double: generator has branched maximum number "
	      << "times;\nindependence of generators no longer guaranteed."
	      << std::endl;
  }
  
  a[length-2] = (INTX2_MASK&b[length-2])<<1;

  for ( i=length-3; i>=0; i--) 
  {
    if ( b[i]&(1<<MAX_BIT_INT) ) 
      a[i+1]++;
    
    a[i] = (INTX2_MASK&b[i])<<1;
  }
}

// Initialize the streams
LFG** LFG::initialize( GeneratorType rng_type_local, 
		       int ngen_local,
		       int param_local,
		       int seed_local,
		       boost::shared_array<unsigned> &nstart_local,
		       unsigned initseed_local )
{
  assert( nstart_local );
  
  int i,j,k,l;
  int length = LFG::valid[param_local].L;
  boost::shared_array<unsigned int> order( new unsigned int[ngen_local] ), 
    nindex;

  // Allocate memory for the fill of each generator
  LFG **q = new LFG *[ngen_local];

  if( q == NULL )
    return NULL;

  for( i=0; i<ngen_local; i++ ) 
  {
    q[i] = new LFG;
    
    if( q[i] == NULL )
      return NULL;
    
    // Initialize generator member data
    q[i]->d_rng_type = rng_type_local;
    q[i]->d_hptr = length - 1;
    q[i]->d_si.reset( new unsigned[length-1] );
    q[i]->d_r0.reset( new unsigned[length] );
    q[i]->d_r1.reset( new unsigned[length] );

    if( q[i]->d_si == NULL || q[i]->d_r0 == NULL || q[i]->d_r1 == NULL )
      return NULL;
    
    q[i]->d_lval = length;
    q[i]->d_kval = LFG::valid[param_local].K;
    q[i]->d_param = param_local;
    q[i]->d_seed = seed_local;
    q[i]->d_init_seed = initseed_local;
    q[i]->d_gentype = GENTYPE;
  }
  
  // Specify register fills and node number arrays. Do fills in tree fashion 
  // so that all fills branch from index contained in nstart array
  q[0]->d_stream_number = nstart_local[0];
  LFG::si_double(q[0]->d_si,nstart_local,length);
  LFG::get_fill(q[0]->d_si,q[0]->d_r0,param_local,seed_local);
  q[0]->d_si[0]++;
  LFG::get_fill(q[0]->d_si,q[0]->d_r1,param_local,seed_local);

  i = 1;
  order[0] = 0;

  if( ngen_local > 1 ) 
  {
    while( true ) 
    {
      l = i;
      for( k=0; k<l; k++) 
      {
	nindex = q[order[k]]->d_si;
	q[i]->d_stream_number = nindex[0];
	LFG::si_double(nindex,nindex, length);

	for (j=0;j<length-1;j++) 
	  q[i]->d_si[j] = nindex[j];

	LFG::get_fill(q[i]->d_si,q[i]->d_r0,param_local,seed_local);
	q[i]->d_si[0]++;
	LFG::get_fill(q[i]->d_si,q[i]->d_r1,param_local,seed_local);

	if( ngen_local == ++i ) 
	  break;
      }
      
      if( ngen_local == i ) 
	break;
                
      for( k=l-1; k>0; k-- ) 
      {
	order[2*k+1] = l+k;
	order[2*k] = order[k];
      }
      order[1] = l;
    }
  }

  order.reset();

  for( i=ngen_local-1; i>=0; i-- ) 
  {
    k = 0;
    
    for( j=1; j < LFG::global_lval-1; j++ )
      if( q[i]->d_si[j] ) 
	k = 1;
    if( !k ) 
      break;
    for( j=0; j<length*RUNUP; j++ )
      q[i]->get_rn_int();
  }

  while( i>=0 )
  {
    for( j=0; j<4*length; j++ ) {
      q[i]->get_rn_int(); 
    }

    i--;
  }   

  return q;
}

// Deep copy arrays
void LFG::deep_copy( const boost::shared_array<unsigned> &orig_array,
		     boost::shared_array<unsigned> &copy_array,
		     const int size )
{
  assert( orig_array );

  // resize the copy array
  copy_array.reset( new unsigned[size] );
  
  for( int i = 0; i < size; ++i )
    copy_array[i] = orig_array[i];
}

// Increment the number of open streams
void LFG::increment_number_of_streams( int num )
{
  LFG::num_generators += num;
  
  if( LFG::num_generators >= LFG::max_streams )
    std::cerr << "WARNING: " << LFG::num_generators << " open LFG streams. "
	      << "Independence can only be guaranteed with " 
	      << LFG::max_streams << " LFG streams."
	      << std::endl;
}

// Decrement the number of open streams
void LFG::decrement_number_of_streams( int num )
{
  LFG::num_generators -= num; 
}

} // end namespace sprng

//---------------------------------------------------------------------------//
// end LFG.cpp
//---------------------------------------------------------------------------//

